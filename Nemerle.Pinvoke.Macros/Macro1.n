using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;

using Nemerle.Pinvoke.CParser;
using Nemerle.Pinvoke.CParser.ReflectionTree;

namespace Nemerle.Pinvoke.Macros
{
  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Assembly)]
  macro Include(files : string, params options : list[PExpr])
  {
    
    def manager = Macros.Manager();
    def projectDir = Path.GetDirectoryName(manager.Options.ProjectPath);
    
    def ParseExternals(externalsList)
    {
        def parse(pExpr)
        {
            | <[$alias = $type]> =>  (alias.ToString(), type.ToString())
        }

        externalsList.Map(p => parse(p))
    }

    mutable externals;

    foreach(item in options)
    {
        | <[ Externals = [..$externalsList]]> => externals = ParseExternals(externalsList)
        | _ => Message.Error("err")
    }
       
    foreach(fileName in Directory.GetFiles(projectDir, files))
    {
        NativeStructImpl.DoTransform(Macros.ImplicitCTX(), fileName, string.Concat(File.ReadAllLines(fileName)), externals)
    }
  }
  
  module NativeStructImpl
  {
    public DoTransform(typer : Typer, _name : string, content : string, _externals : list.[string * string]) : void
    {
      Macros.DefineCTX(typer);

      def parser = DeclarationsParser();
      
      unless (Nemerle.Macros.ImplicitCTX().Manager.IsIntelliSenseMode)
      {
          _ = Debugger.Launch();
      }
      
      def str = parser.Parse(content);

      def reflectionTree = str.Map(CParser.TreeConverter.Convert).WithDefault([]);

      CodeGenerator.Generate(reflectionTree, typer)
    }


}
}
