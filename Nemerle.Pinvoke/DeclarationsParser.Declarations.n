using Nemerle;
using Nemerle.Collections;
using Nemerle.Peg;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.ComputationExpressions;

using System;
using System.Collections.Generic;
using System.Linq;

using Nemerle.Pinvoke.Ast.Declarations;
using Nemerle.Pinvoke.Ast.Declarations.DeclarationSpecifiers;
using Nemerle.Pinvoke.Ast.Declarations.Declarator;
using Nemerle.Pinvoke.Ast.Expressions;
using Nemerle.Pinvoke.Ast.Identifiers;

namespace Nemerle.Pinvoke
{
  public partial class DeclarationsParser
  {
     // declarationSpecifiers initDeclaratorList? s ';'s
     normalDeclaration(declarationSpecifiers : list[DeclarationSpecifier], initDeclarationList : option[list[InitDeclarator]], _ : NToken) : Declaration
     {
        Declaration.Normal(declarationSpecifiers, initDeclarationList)
     }

     // "_Static_assert"s '('s constantExpression ','s stringLiteral ')'s
     staticAssertDeclaration(_ : NToken, _ : NToken, _ : ConstantExpression, _ : NToken, _ : NToken, _ : NToken) : Declaration
     {
        Declaration.StaticAssert()
     }

     declarationSpecifiers(lst : List[DeclarationSpecifier]) : list[DeclarationSpecifier]
     {
        NList.ToList(lst)
     }

     // initDeclarator (s ',' initDeclarator)*;
     initDeclaratorList(firstInitDeclarator : InitDeclarator, tailList : List[(NToken * InitDeclarator)]) : list[InitDeclarator]
     {
        firstInitDeclarator.Cons(tailList)
     }

     normalInitDeclarator(declarator : Declarator) : InitDeclarator
     {
        InitDeclarator(declarator)
     }

     initDeclaratorWithInitializer(declarator : Declarator, _ : NToken, _ : NToken) : InitDeclarator
     {
        InitDeclarator(declarator)
     }

     storageClassSpecifier(token : NToken) : DeclarationSpecifier
     {
        def storageClassSpecifier = 
        match(GetText(token))
        {
           | "typedef"        => StorageClassSpecifier.Typedef()
           | "extern"         => StorageClassSpecifier.Extern()
           | "static"         => StorageClassSpecifier.Static()
           | "_Thread_local"  => StorageClassSpecifier.ThreadLocal()
           | "auto"           => StorageClassSpecifier.Auto()
           | "register"       => StorageClassSpecifier.Register()
           | _                => throw InvalidOperationException($"Unknown storage class: $(GetText(token))");
        }

        DeclarationSpecifier.StorageClass(value = storageClassSpecifier)
     }

     builtInTypeSpecifier(token : NToken) : DeclarationSpecifier
     {
        def typeSpecifier = 
        match(GetText(token))
        {
           | "void"           => TypeSpecifier.Void()
           | "char"           => TypeSpecifier.Char()
           | "short"          => TypeSpecifier.Short()
           | "int"            => TypeSpecifier.Int()
           | "long"           => TypeSpecifier.Long()
           | "float"          => TypeSpecifier.Float()
           | "double"         => TypeSpecifier.Double()
           | "signed"         => TypeSpecifier.Signed()
           | "unsigned"       => TypeSpecifier.Unsigned()
           | "_Bool"          => TypeSpecifier.Bool()
           | "_Complex"       => TypeSpecifier.Complex()
           | _                => throw InvalidOperationException($"Unknown type specifier: $(GetText(token))");
        }

        DeclarationSpecifier.TypeSpecifier(value = typeSpecifier);
     }

     structOrUnionTypeSpecifier(structOrUnionSpecifier : StructOrUnionSpecifier) : DeclarationSpecifier
     {
        def typeSpecifier = TypeSpecifier.StructOrUnion(specifier = structOrUnionSpecifier);
        DeclarationSpecifier.TypeSpecifier(value = typeSpecifier)
     }

     enumTypeSpecifier(enumSpecifier : EnumSpecifier) : TypeSpecifier
     {
        TypeSpecifier.Enum(specifier = enumSpecifier);
     }

     typedefTypeSpecifier(token : NToken) : TypeSpecifier
     {
        TypeSpecifier.TypedefName(GetText(token));
     }

     // "_Atomic"s '('s typeName ')'s;
     atomicTypeSpecifier(_Atomic : NToken, _leftParenthesis : NToken, typeName : TypeName, _rightParenthesis : NToken) : TypeSpecifier
     {
        TypeSpecifier.AtomicTypeSpecifier( typeName = typeName);
     }

     typeDeclarationSpecifier(typeSpecifier : TypeSpecifier) : DeclarationSpecifier
     {
        DeclarationSpecifier.TypeSpecifier(value = typeSpecifier);
     }

     // "enum"s identifier? '{'s enumeratorList ','s '}'s;
     enumSpecifierWithComma(_enum : NToken, name : option[Identifier], _leftBrace : NToken, enumerators : list[Enumerator], _comma : NToken, _rightBrace : NToken) : EnumSpecifier
     {
        EnumSpecifier(name, option.Some(enumerators))
     }

     // "enum"s identifier? '{'s enumeratorList s '}'s;
     normalEnumSpecifier(_enum : NToken, name : option[Identifier], _leftBrace : NToken, enumerators : list[Enumerator], _rightBrace : NToken) : EnumSpecifier
     {
        EnumSpecifier(name, option.Some(enumerators))
     }

     // "enum"s identifier;
     forwardDeclarationEnumSpecififer(_enum : NToken, name : Identifier) : EnumSpecifier
     {
        EnumSpecifier(Some(name), None())
     }

     enumeratorList(head : Enumerator, tail : List[(NToken * Enumerator)]) : list[Enumerator]
     {
        head.Cons(tail)
     }

     normalEnumerator(name  : Identifier) : Enumerator
     {
        Enumerator(name, None())
     }

     enumeratorWithExplicitValue(name : Identifier, _ : NToken, initializer : ConstantExpression) : Enumerator
     {
        Enumerator(name, Some(initializer))
     }

     // structOrUnion S identifier
     forwardDeclarationStructOrUnionSpecifier(structOrUnion : StructOrUnion, name : Identifier) : StructOrUnionSpecifier
     {
        StructOrUnionSpecifier.ForwardDeclaration(structOrUnion, Some(name)) 
     }

     // (structOrUnion S identifier? s '{'s structDeclarationList s '}');
     declarationStructOrUnionSpecifier(structOrUnion  : StructOrUnion, name : option[Identifier], _leftBrace : NToken, structDeclarationList : list[StructDeclaration], _rightBrace : NToken) : StructOrUnionSpecifier
     {
        StructOrUnionSpecifier.Declaration(structOrUnion, name, structDeclarationList) 
     }

     // ("struct" / "union")S
     structOrUnion(token : NToken) : StructOrUnion
     {
       match(GetText(token))
       {
           | "struct" => StructOrUnion.Struct()
           | "union"  => StructOrUnion.Union()
           | _        => throw InvalidOperationException($"Unknown structOrUnion keyword: $(GetText(token))");
       }
     }

     structDeclarationList(lst : List[StructDeclaration]) : list[StructDeclaration]
     {
        NList.ToList(lst)
     }

     // specifierQualifierList structDeclaratorList? ";"s;
     normalStructDeclaration(declarationSpecifierList : list[DeclarationSpecifier], structDeclaratorList : option[list[StructDeclarator]], _ : NToken) : StructDeclaration
     {
        StructDeclaration(declarationSpecifierList, structDeclaratorList.WithDefault([]))
     } 
     
     typeSpecifierSpecifierQualifierList(head : TypeSpecifier, tail : option[list[DeclarationSpecifier]]) : list[DeclarationSpecifier]
     {
        DeclarationSpecifier.TypeSpecifier(head) :: tail.WithDefault([])
     }

     typeQualifierSpecifierQualifierList(head : TypeQualifier, tail : list[DeclarationSpecifier]) : list[DeclarationSpecifier]
     {
        DeclarationSpecifier.TypeQualifier(head) :: tail
     }

     structDeclaratorList(_ : NToken, _ : List[(Nemerle.Peg.NToken * Nemerle.Peg.NToken)]) : list[StructDeclarator]
     {
        []
     }

     normalStructDeclarator(declarator : Declarator) : StructDeclarator
     {
        StructDeclarator.NormalDeclarator(declarator)
     }

     bitFieldStructDeclarator(declarator : option[Declarator.Declarator], _ : NToken, constantExpression : ConstantExpression) : StructDeclarator
     {
        StructDeclarator.BitFieldDeclarator(declarator, constantExpression);
     }

     staticAssertStructDeclaration(_ : Declaration) : StructDeclaration
     {
        StructDeclaration([], [])
     }

     typeQualifier(token : NToken) : TypeQualifier
     {
        match(GetText(token))
        {
           | "const"        => TypeQualifier.Const()
           | "restrict"     => TypeQualifier.Restrict()
           | "volatile"     => TypeQualifier.Volatile()
           | "_Atomic"      => TypeQualifier.Atomic()
           | _              => throw InvalidOperationException($"Unknown type qualifier: $(GetText(token))");
        }
     }

     typeQualifeierDeclarationSpecifier(typeQualifier : TypeQualifier) : DeclarationSpecifier
     {
        DeclarationSpecifier.TypeQualifier(value = typeQualifier)
     }

     // "inline" / "_Noreturn"
     functionSpecifier(token : NToken) : FunctionSpecifier
     {
        match(GetText(token))
        {
           | "inline"          => FunctionSpecifier.Inline()
           | "_Noreturn"       => FunctionSpecifier.NoReturn()
           | _                 => throw InvalidOperationException($"Unknown function specifier: $(GetText(token))");
        }
     }

     functionDeclarationSpecifier(functionSpecifier : FunctionSpecifier) : DeclarationSpecifier
     {
        DeclarationSpecifier.Function(value = functionSpecifier)
     }

     // s '('s constantExpression s ')'
     expressionAlignmentSpecifier(_ : NToken, _ : ConstantExpression, _ : NToken) : AlignmentSpecifier
     {
        AlignmentSpecifier.Expression()
     }

     // '('s typeName s ')'
     alignAsAlignmentSpecifier(_ : NToken, _ : TypeName, _ : NToken) : AlignmentSpecifier
     {
        AlignmentSpecifier.AlignAsType()
     }
     
     // "_Alignas" (s alignAsAlignmentSpecifier / expressionAlignmentSpecifier s)
     alignmentSpecifier(_ : NToken, alignmentSpecifier : DeclarationSpecifiers.AlignmentSpecifier) : AlignmentSpecifier
     {
        alignmentSpecifier  
     }

     alignmentDeclarationSpecifier(alignmentSpecifier : AlignmentSpecifier) : DeclarationSpecifier
     {
        DeclarationSpecifier.Alignment(value = alignmentSpecifier)
     }



     // pointer? s directDeclarator
     declarator(ptr : option[Pointer], directDeclarator : DirectDeclarator) : Declarator
     {
        Declarator(ptr, directDeclarator)
     }

     typeQualifierList(lst : List[TypeQualifier]) : list[TypeQualifier]
     {
        NList.ToList(lst)
     }

     parameterTypeList(parameterDeclarationList : list[ParameterDeclaration], ellipsis : option[(NToken * NToken)]) : (list[ParameterDeclaration] * bool)
     {
        (parameterDeclarationList, ellipsis.HasValue)
     }

     simpleDirectDeclaratorHead(name : Identifier) : DirectDeclaratorHead
     {
        DirectDeclaratorHead.Simple(name)
     }

     recurrentDirectDeclaratorHead(_ : NToken, declarator : Declarator, _ : NToken) : DirectDeclaratorHead
     {
        DirectDeclaratorHead.Recurrent(declarator)
     }

     assignmentExpressionDirectDeclaratorTailElement(_ : NToken, typeQualifiers : option[list[TypeQualifier]], _ : NToken, _ : NToken) : DirectDeclaratorTailElement
     {
        DirectDeclaratorTailElement.AssignmentExpression(typeQualifiers.WithDefault([]), AssignmentExpression())
     }

     static1AssignmentExpressionDirectDeclaratorTailElement(_ : NToken, _ : NToken, typeQualifiers : option[list[TypeQualifier]], _ : NToken, _ : NToken) : DirectDeclaratorTailElement
     {
        DirectDeclaratorTailElement.StaticAssignmentExpression1(typeQualifiers.WithDefault([]), AssignmentExpression())
     }

     static2AssignmentExpressionDirectDeclaratorTailElement(_ : NToken, typeQualifiers : list[TypeQualifier], _ : NToken, _ : NToken, _ : NToken) : DirectDeclaratorTailElement
     {
             DirectDeclaratorTailElement.StaticAssignmentExpression2(typeQualifiers, AssignmentExpression())
     }

     asterikDirectDeclaratorTailElement(_ : NToken, typeQualifiers : option[list[TypeQualifier]], _ : NToken, _ : NToken) : DirectDeclaratorTailElement
     {
        DirectDeclaratorTailElement.Asterik(typeQualifiers.WithDefault([]))
     }

     FunctionWithParametersDirectDeclaratorTailElement(_ : NToken, parameters : (list[ParameterDeclaration] * bool), _ : NToken) : DirectDeclaratorTailElement
     {
        DirectDeclaratorTailElement.FunctionWithParameters()
     }

     FunctionWithIdentifiersDirectDeclaratorTailElement(_ : NToken, _ : option[list[Identifier]], _ : NToken) : DirectDeclaratorTailElement
     {
        DirectDeclaratorTailElement.FunctionWithIdentifiers()
     }

     directDeclarator(head : Declarator.DirectDeclaratorHead, tail : List[DirectDeclaratorTailElement]) : Declarator.DirectDeclarator
     {
        DirectDeclarator(head, NList.ToList(tail))
     }
     

     normalPointer(_asterik : NToken, qualifierList : option[list[TypeQualifier]]) : Pointer
     {
        Pointer(qualifierList, option.None());
     }

     recurrentPointer(_asterik : NToken, qualifierList : option[list[TypeQualifier]], innerPointer : Pointer) : Pointer
     {
        Pointer(qualifierList, option.Some(innerPointer))
     }

     parameterList(parameterDeclaration : ParameterDeclaration, parameterDeclarationList : List[(NToken * ParameterDeclaration)]) : list[ParameterDeclaration]
     {
        parameterDeclaration.Cons(parameterDeclarationList);
     }

     normalParameterDeclaration(declarationSpecifiers : list[DeclarationSpecifier], declarator : Declarator.Declarator) : ParameterDeclaration
     {
        ParameterDeclaration(declarationSpecifiers, declarator)
     }

     abstractParameterDeclaration(declarationSpecifiers : list[DeclarationSpecifier], abstractDeclarator : option[Declarator.AbstractDeclarator]) : ParameterDeclaration
     {
        ParameterDeclaration(declarationSpecifiers, abstractDeclarator)
     }

     identifierList(head : Identifier, tail : List[(NToken * Identifier)]) : list[Identifier]
     {
        head.Cons(tail)
     }

     singularPointerAbstractDeclarator(pointer : Pointer) : Declarator.AbstractDeclarator
     {
        AbstractDeclarator(Some(pointer), None())
     }

     normalAbstractDeclarator(pointer : option[Pointer], directAbstractDeclarator : DirectAbstractDeclarator) : AbstractDeclarator
     {
        AbstractDeclarator(pointer, Some(directAbstractDeclarator));
     }

     assignmentExpressionDirectAbstractDeclaratorTailElement(_ : NToken, typeQualifierList : option[list[DeclarationSpecifiers.TypeQualifier]], _ : NToken, _ : NToken) : Declarator.DirectAbstractDeclaratorTailElement
     {
        DirectAbstractDeclaratorTailElement.AssignmentExpression(typeQualifierList.WithDefault([]), AssignmentExpression())
     }
     
     static1AssignmentExpressionDirectAbstractDeclaratorTailElement(_ : NToken, _ : NToken, typeQualifierList : option[list[DeclarationSpecifiers.TypeQualifier]], _ : NToken, _ : NToken) : Declarator.DirectAbstractDeclaratorTailElement
     {
        DirectAbstractDeclaratorTailElement.StaticAssignmentExpression1(typeQualifierList.WithDefault([]), AssignmentExpression())
     }

     static2AssignmentExpressionDirectAbstractDeclaratorTailElement(_ : NToken, typeQualifierList : list[DeclarationSpecifiers.TypeQualifier], _ : NToken, _ : NToken, _ : NToken) : DirectAbstractDeclaratorTailElement
     {
        DirectAbstractDeclaratorTailElement.StaticAssignmentExpression2(typeQualifierList, AssignmentExpression())
     }

     asterikDirectAbstractDeclaratorTailElement(_ : NToken, _ : NToken, _ : NToken) : DirectAbstractDeclaratorTailElement
     {
        DirectAbstractDeclaratorTailElement.Asterik()
     }

     FunctionWithParametersDirectAbstractDeclaratorTailElement(_ : NToken, _ : option[(list[ParameterDeclaration] * bool)], _ : NToken) : DirectAbstractDeclaratorTailElement
     {
        DirectAbstractDeclaratorTailElement.FunctionWithParameters()
     }
     
     normalDirectAbstractDeclarator(_leftParentesis : NToken, abstractDeclarator : AbstractDeclarator, _rightParentesis : NToken, tail : List[DirectAbstractDeclaratorTailElement]) : DirectAbstractDeclarator
     {
        DirectAbstractDeclarator(Some(abstractDeclarator), NList.ToList(tail))
     }

     singularDirectAbstractDeclarator(tail : List[DirectAbstractDeclaratorTailElement]) : DirectAbstractDeclarator
     {
        DirectAbstractDeclarator(None(), NList.ToList(tail))
     }
  }
}
