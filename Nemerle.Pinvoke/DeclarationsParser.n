using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Peg;

using System;
using System.Collections.Generic;
using System.Linq;

using Nemerle.Pinvoke.AST;

namespace Nemerle.Pinvoke
{
  [PegGrammar(Options = EmitDebugSources, declaration,
  grammar
  {
      start : NToken      = ";"s;
      any                 = ['\u0000'..'\uFFFF'];
      
      #region Line terminators

      newLineCharacter = '\n'
                        / '\r'
                        / '\u2028'    /*  line separator       */
                        / '\u2029';   /*  paragraph separator  */
      newLine   = "\r\n" / newLineCharacter;

      #endregion

      #region White space

      whitespace = [Zs]
                / '\t'
                / '\v'        /*  vertial tab          */
                / '\f';       /*  form feed            */

      #endregion

      #region Spacer

      space = whitespace / newLine;
      
      [InlineAllSubrules]
      s : void = space*;                      /* optional spacer          */
      S : void = !identifierBody s;           /* identifier break spacer  */
      
      #endregion
      
      #region A.1.2 Keywords
      
      keyword = ("auto"           / "break"         / "case"      /
                 "char"           / "const"         / "continue"  /
                 "default"        / "do"            / "double"    /
                 "else"           / "enum"          / "extern"    /
                 "float"          / "for"           / "goto"      /
                 "if"             / "inline"        / "int"       /
                 "long"           / "register"      / "restrict"  /
                 "return"         / "short"         / "signed"    /
                 "sizeof"         / "static"        / "struct"    /
                 "switch"         / "typedef"       / "union"     /
                 "unsigned"       / "void"          / "volatile"  /
                 "while"          / "_Alignas"      / "_Alignof"  /
                 "_Atomic"        / "_Bool"         / "_Complex"  /
                 "_Generic"       / "_Imaginary"    / "_Noreturn" /
                 "_Static_assert" / "_Thread_local" ) !identifierBody;
                 
      #endregion
      
      #region A.1.3 Identifiers
      
      digit            = ['0'..'9'];
      nonDigit		   = ['a'..'z', 'A'..'Z'] / '_' / universalCharacterName;
      identifierBody   = nonDigit (nonDigit / digit)*;
      identifier : string   = !keyword identifierBody s;
      
      #endregion
      
      #region A.1.4 Universal character names
      
      hexQuad                = hexadecimalDigit hexadecimalDigit hexadecimalDigit hexadecimalDigit;
      universalCharacterName = "\\u" hexQuad / "\\U" hexQuad hexQuad;
      
      #endregion

      #region A.1.5 Constants
      
      constant        = integerConstant     /
                        floatingConstant    /
                        enumerationConstant /
                        characterConstant;
                        
      integerConstant = decimalConstant integerSuffix? /
                        octalConstant integerSuffix?   /
                        hexadecimalConstant integerSuffix?;
                        
      decimalConstant = nonzeroDigit digit+;
                        
      octalConstant   = '0' octalDigit+;
                        
      hexadecimalConstant = hexadecimalPrefix hexadecimalDigit+;
      
      hexadecimalPrefix   = "0x" / "0X";
      
      nonzeroDigit          = ['1'..'9'];
      
      octalDigit            = ['0'..'7'];
      
      hexadecimalDigit      = ['0'..'9', 'A'..'F', 'a'..'f'];
      
      integerSuffix = unsignedSuffix longSuffix?     /
                      unsignedSuffix longLongSuffix  /
                      longSuffix     unsignedSuffix? /
                      longLongSuffix unsignedSuffix?;
                      
      unsignedSuffix = 'u' / 'U';
      
      longSuffix     = 'l' / 'L';
      
      longLongSuffix = "ll" / "LL";
      
      floatingConstant = decimalFloatingConstant /
                         hexadecimalFloatingConstant;
                         
      decimalFloatingConstant = fractionalConstant exponentPart? floatingSuffix?
                                digitSequence exponentPart floatingSuffix?;
                                
      hexadecimalFloatingConstant = hexadecimalPrefix hexadecimalFractionalConstant binaryExponentPart floatingSuffix? /
                                    hexadecimalPrefix hexadecimalDigitSequence binaryExponentPart floatingSuffix?;
                                    
      fractionalConstant         = digitSequence? '.' digitSequence / 
                                   digitSequence '.';
                                   
      exponentPart               = 'e' sign? digitSequence /
                                   'E' sign? digitSequence;
                                   
      sign                       = '+' / 
                                   '-';
                                   
      digitSequence              =  digit+;
      
      hexadecimalFractionalConstant = hexadecimalDigitSequence? '.' hexadecimalDigitSequence /
                                      hexadecimalDigitSequence '.';
                                      
      binaryExponentPart = 'p' sign? digitSequence /
                           'P' sign? digitSequence;
                           
      hexadecimalDigitSequence = hexadecimalDigit+;
      
      floatingSuffix = 'f' / 'l' / 'F' / 'L';
      
      enumerationConstant   = identifier;
      
      characterConstant     = "'" cCharSequence "'"  /
                              "L'" cCharSequence "'" /
                              "u'" cCharSequence "'" /
                              "U'" cCharSequence "'";
                              
      cCharSequence = cChar+;
      
      cChar = !(newLineCharacter / '\'' / '\\') any / escapeSequence;
      
      escapeSequence        = simpleEscapeSequence      /
                              octalEscapeSequence       /
                              hexadecimalEscapeSequence /
                              universalCharacterName;
                              
      simpleEscapeSequence = '\\' ('\'' / '"' / '?' / '\\' / 'a' / 'b' / 'f' / 'n' / 'r' / 't' / 'v');
      
      octalEscapeSequence       = '\\' octalDigit octalDigit? octalDigit?;
      
      hexadecimalEscapeSequence = "\\x" hexadecimalDigit+;
      
      #endregion
      
      #region A.1.6 String literals
      
      stringLiteral = encodingPrefix? '"' sCharSequence '"';
      
      encodingPrefix = "u8" /
                       "u"  /
                       "U"  /
                       "L";
      
      sCharSequence = sChar*;
      
      sChar = !(newLineCharacter / '"' / '\\') any / escapeSequence / universalCharacterName;
      
      #endregion
      
      #region A.2.1 Expressions
      
      primaryExpression = identifier             /
                          constant               /
                          stringLiteral          /
                          '('s expression s ')' /
                          genericSelection;
                          
      genericSelection = "_Generic"s '('s assignmentExpression ','s genericAssocList ')'s;
      
      genericAssocList = genericAssociation (','s genericAssociation)*;
      
      genericAssociation = typeName ':'s assignmentExpression /
                           "default"s ':'s assignmentExpression;
      
      postfixExpressionTail = '['s expression ']'s  /
                              argumentExpressionList? /
                              '.'s identifier        /
                              "->"s identifier       /
                              "++"                    /
                              "--"; 
      postfixExpression = primaryExpression / ('('s typeName ')'s '{'s initializerList (','s)? '}'s) postfixExpressionTail*;
                         
      argumentExpressionList = assignmentExpression (s ','s assignmentExpression)*;
      
      unaryExpression = postfixExpression               /
                        "++"s unaryExpression          /
                        "--"s unaryExpression          /
                        unaryOperator castExpression    /
                        "sizeof"s unaryExpression      /
                        "sizeof"s '('s typeName ')'s /
                        "_Alignof"s '('s typeName ')'s;
                        
      unaryOperator = '&' / '*' / '+' / '-' / '~' / '!';
      
      castExpression = unaryExpression /
                       '('s typeName ')'s castExpression;
      
      multiplicativeExpressionTail = '*'s castExpression /
                                     '/'s castExpression /
                                     '%'s castExpression;
      multiplicativeExpression     = castExpression multiplicativeExpressionTail*;
      
      additiveExpressionTail       = '+'s multiplicativeExpression /
                                     '-'s multiplicativeExpression;
      additiveExpression           = multiplicativeExpression additiveExpressionTail*;
      
      shiftExpressionTail          = "<<"s additiveExpression /
                                     ">>"s additiveExpression;
      shiftExpression              = additiveExpression shiftExpressionTail*;
      
      relationalExpressionTail     = '<'s shiftExpression  /
                                     '>'s shiftExpression  /
                                     "<="s shiftExpression /
                                     ">="s shiftExpression;
      relationalExpression        = shiftExpression relationalExpressionTail*;
      
      equalityExpressionTail      = "=="s relationalExpression /
                                    "!="s relationalExpression;
      equalityExpression          = relationalExpression equalityExpressionTail*;
      
      andExpression               = equalityExpression ("&"s equalityExpression)*;
      
      exclusiveOrExpression       = andExpression ('^'s andExpression)*;
      
      inclusiveOrExpression       = exclusiveOrExpression ('|'s exclusiveOrExpression)*;
      
      logicalAndExpression        = inclusiveOrExpression ("&&"s inclusiveOrExpression)*;

      logicalOrExpression         = logicalAndExpression ("||"s logicalAndExpression)*;
      
      conditionalExpression       = logicalOrExpression ("?"s expression ":"s conditionalExpression)*;
      
      assignmentExpression        = conditionalExpression /
                                    unaryExpression assignmentOperator assignmentExpression;
                                 
      assignmentOperator = "=" / "*=" / "/=" / "%=" / "+=" / "-=" / "<<=" / ">>=" / "&=" / "^=" / "|=";
      
      expression = assignmentExpression (','s assignmentExpression)*;
      
      constantExpression = conditionalExpression;
            
      #endregion
      
      #region A.2.2 Declarations

      normalDeclaration : Declaration = declarationSpecifiers initDeclaratorList? ';'s;
      
      declaration : Declaration =   normalDeclaration  /
                                    staticAssertDeclaration;
                          
      declarationSpecifiers = storageClassSpecifier declarationSpecifiers? /
                              typeSpecifier declarationSpecifiers?         /
                              typeQualifier declarationSpecifiers?         /
                              functionSpecifier declarationSpecifiers?     /
                              alignmentSpecifier declarationSpecifiers?;
                              
      initDeclaratorList    = initDeclarator (','s initDeclarator)*;
      
      initDeclarator        = declarator /
                              declarator '='s initializer;
                              
      storageClassSpecifier = "typedef"       /
                              "extern"        /
                              "static"        /
                              "_Thread_local" /
                              "auto"          /
                              "register";
                              
      typeSpecifier         = "void"                 / 
                              "char"                 / 
                              "short"                / 
                              "int"                  / 
                              "long"                 /
                              "float"                /
                              "double"               /
                              "signed"               /
                              "unsigned"             /
                              "_Bool"                /
                              "_Complex"             /
                              atomicTypeSpecifier    /
                              structOrUnionSpecifier /
                              enumSpecifier          /
                              typedefName;
      
      forwardDeclarationStructOrUnionSpecifier : StructOrUnionSpecifier = structOrUnion S identifier;
      declarationStructOrUnionSpecifier        : StructOrUnionSpecifier = (structOrUnion S identifier? '{'s structDeclarationList '}'s);
      structOrUnionSpecifier                   : StructOrUnionSpecifier = forwardDeclarationStructOrUnionSpecifier / 
                                                                          declarationStructOrUnionSpecifier;
      
      structOrUnion : StructOrUnion   = ("struct" / "union")S;
      
      structDeclarationList : List[StructDeclaration] = structDeclaration+;
      
      normalStructDeclaration : StructDeclaration= specifierQualifierList structDeclaratorList? ';'s;
      
      
      structDeclaration  : StructDeclaration = normalStructDeclaration /
                                               staticAssertStructDeclaration;
                              
      specifierQualifierList = typeSpecifier specifierQualifierList? /
                               typeQualifier specifierQualifierList;
                               
      structDeclaratorList   = structDeclarator (','s structDeclarator)*;
      
      structDeclarator       = declarator /
                               declarator? ':'s constantExpression;
                               
      enumSpecifier = "enum"s identifier? '{'s enumeratorList '}'s      /
                      "enum"s identifier? '{'s enumeratorList ','s '}'s /
                      "enum"s identifier;
      
      enumeratorList = enumerator (','s enumerator)*;
      
      enumerator     = enumerationConstant /
                       enumerationConstant '='s constantExpression;
                       
      atomicTypeSpecifier = "_Atomic"s '('s typeName ')'s;
      
      typeQualifier = "const"    / 
                      "restrict" /
                      "volatile" /
                      "_Atomic";
                      
      functionSpecifier = "inline" / 
                          "_Noreturn";
                          
      alignmentSpecifier = "_Alignas" ('('s typeName ')'s / 
                                       '('s constantExpression ')'s);
      
      declarator : Declarator   = pointer? s directDeclarator;
      
      directDeclaratorHead = identifier /
                             '('s declarator ')'s;
      directDeclaratorTail = 
        '['s  typeQualifierList? assignmentExpression? ']'s         /
        '['s "static"s typeQualifierList? assignmentExpression ']'s /
        '['s typeQualifierList "static"s assignmentExpression ']'s  /
        '['s typeQualifierList? '*'s ']'s                           /
        '('s parameterTypeList ')'s                                 /
        '('s identifierList? ')'s;
        
      directDeclarator = directDeclaratorHead directDeclaratorTail*;
      
      pointer = '*'s typeQualifierList? /
                '*'s typeQualifierList? pointer;
                
      typeQualifierList = typeQualifier+;
      
      parameterTypeList    = parameterList (','s "..."s)?;
      parameterList        = parameterDeclaration (','s parameterDeclaration)*;
      parameterDeclaration = declarationSpecifiers (declarator / abstractDeclarator?);
      
      identifierList = identifier (','s identifier)*;
      
      typeName       = specifierQualifierList abstractDeclarator?;
 
      abstractDeclarator = pointer /
                           pointer? directAbstractDeclarator;

      
      directAbstractDeclaratorHead = '('s abstractDeclarator ')'s;
      directAbstractDeclaratorTail =  '['s typeQualifierList? assignmentExpression? ']'s          /
                                      '['s "static"s typeQualifierList? assignmentExpression ']'s /
                                      '['s typeQualifierList "static"s assignmentExpression ']'s  /
                                      '['s '*'s ']'s                                              /
                                      '('s parameterTypeList? ')'s;
      directAbstractDeclarator      = (directAbstractDeclaratorHead / directAbstractDeclaratorTail) directAbstractDeclaratorTail*;  
                       
      typedefName    = identifier;
      
      initializer    = assignmentExpression      / 
                       '{'s initializerList '}'s /
                       '{'s initializerList ','s '}'s;
      
      initializerListElement = designation? initializer;
      initializerList        = initializerListElement (','s initializerListElement)*;
                        
      designation = designatorList '='s;
      
      designatorList = designator+;
      
      designator = '['s constantExpression ']'s /
                    '.'s identifier;
                    
      staticAssertStructDeclaration : StructDeclaration = staticAssertDeclaration;
      staticAssertDeclaration       : Declaration       = "_Static_assert"s '('s constantExpression ','s stringLiteral ')'s;
      
      #endregion
      
      #region A.2.3 Statements
      
      statement = labeledStatement    /
                  compoundStatement   /
                  expressionStatement /
                  selectionStatement  /
                  iterationStatement  /
                  jumpStatement;
                  
      labeledStatement = identifier ':'s statement                 /
                         "case"s constantExpression ':'s statement /
                         "default"s ':'s statement;
                         
      compoundStatement = '{'s blockItemList? '}'s;
      
      blockItemList     = blockItem+;
      blockItem         = declaration /
                          statement;
                          
      expressionStatement = expression? ';'s;
      
      selectionStatement  = "if"s '('s expression ')'s statement ("else"s statement)? /
                            "switch"s '('s expression ')'s statement;
                            
      iterationStatement  = "while"s '('s expression ')'s statement                                  /
                            "do"s statement "while"s '('s expression ')'s ';'s                       /
                            "for"s '('s expression? ';'s expression? ';'s expression? ')'s statement /
                            "for"s '('s declaration expression? ';'s expression? ')'s statement;
                            
      jumpStatement     = "goto"S identifier ';'s /
                          "continue"s ';'s        /
                          "break"s ';'s           /
                          "return"s expression? ';'s;

      #endregion
      
  })]
  public class DeclarationsParser
  {
     identifier(token : Nemerle.Peg.NToken) : string
     {
        GetText(token)
     }

      structOrUnion(token : Nemerle.Peg.NToken) : Nemerle.Pinvoke.AST.StructOrUnion
      {
        match(GetText(token))
        {
            | "struct" => StructOrUnion.Struct()
            | "union"  => StructOrUnion.Union()
        }
      }

     normalDeclaration(_ : Nemerle.Peg.NToken, _ : Nemerle.Peg.NToken, _ : Nemerle.Peg.NToken) : Declaration
     {
        Declaration()
     }

     // (structOrUnion S identifier? s '{'s structDeclarationList s '}');
     declarationStructOrUnionSpecifier(structOrUnion  : StructOrUnion, name : option[string], _leftBrace : Nemerle.Peg.NToken, structDeclarationList : List[Nemerle.Pinvoke.AST.StructDeclaration], _rightBrace : Nemerle.Peg.NToken) : StructOrUnionSpecifier
     {
        StructOrUnionSpecifier.Declaration(structOrUnion, name, structDeclarationList) 
     }
    
     forwardDeclarationStructOrUnionSpecifier(structOrUnion : StructOrUnion, name : string) : StructOrUnionSpecifier
     {
        StructOrUnionSpecifier.ForwardDeclaration(structOrUnion, option.Some(name)) 
     }

     declarator(ptr : Nemerle.Peg.NToken, _ : Nemerle.Peg.NToken) : Nemerle.Pinvoke.AST.Declarator
     {
        Declarator(isPointer = !ptr.IsEmpty)
     }
    
     normalStructDeclaration(_ : Nemerle.Peg.NToken, _ : Nemerle.Peg.NToken, _ : Nemerle.Peg.NToken) : StructDeclaration
     {
        StructDeclaration()
     } 
     
     staticAssertDeclaration(_ : Nemerle.Peg.NToken, _ : Nemerle.Peg.NToken, _ : Nemerle.Peg.NToken, _ : Nemerle.Peg.NToken, _ : Nemerle.Peg.NToken, _ : Nemerle.Peg.NToken) : Declaration
     {
        Declaration()
     }

     staticAssertStructDeclaration(_ : Declaration) : StructDeclaration
     {
        StructDeclaration()
     }
  }
}
